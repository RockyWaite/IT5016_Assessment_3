Batu Waite (20230410) Assessment 3: Research Repository

Repository Link: https://github.com/RockyWaite/IT5016_Assessment_3


What I've learned or found interesting.

1. Hangman:

User Input Handling: I gained experience in handling user input for guessing letters, which is applicable for capturing user requests or data entry in my ticketing system.

Conditional Statements: The game required me to use conditional statements to evaluate correct and incorrect guesses. I can apply these skills to make decisions based on user actions within my ticketing application.

Loops: Hangman utilized a while loop for interactive gameplay, teaching me how to create a loop structure for my ticketing system's menu, allowing users like me to perform multiple actions sequentially.

Game Logic: I was exposed to basic game logic involving word selection, letter matching, and win/lose conditions. This understanding can help me define logical operations and workflows within my ticketing system.

Interactive User Experience: The Hangman game provided me with insights into user-friendly interactions, such as displaying the current state of the word and providing feedback on correct or incorrect guesses. These principles can be applied to create an intuitive and interactive interface for my ticketing application.



2. Rock, Paper, Scissors

User Input Handling: I practiced receiving and validating user input for making choices, a crucial skill for accepting user commands or preferences in my ticketing system.

Conditional Statements: The game required me to use conditional statements to determine the winner based on my and the computer's choices. I can leverage these structures to implement various decision-making processes within my ticketing application.

Random Number Generation: The Rock, Paper, Scissors game used randomization to simulate the computer's choice, teaching me how to apply random number generation techniques for tasks like generating unique ticket IDs or shuffling lists of tickets.

Game Logic: I encountered simple game rules and logic for determining outcomes, which can be used to establish rules for ticket management, status changes, and calculations within my ticketing system.

Interactive User Experience: The Rock, Paper, Scissors game offered me an interactive experience with clear instructions and outcome messages. I can employ similar strategies to create an engaging user interface in my ticketing application, ensuring users like me can easily navigate and understand the system's features.



3. Calculator Project (Level 4)

Command-Line Interface (CLI) Development: I've gained experience in creating command-line interfaces, allowing users like me to interact with the program through text-based commands. This knowledge can be applied to designing user-friendly text-based interfaces for various software applications, including my ticketing system.

Input Handling: I've learned how to handle user input from the command line, such as parsing commands and arguments. This skill is transferable to my ticketing system, where I can respond to user input, like creating tickets or editing information, via text-based commands.

Error Handling: My calculator project includes error handling, such as catching exceptions and displaying error messages in the console. This is essential for maintaining robust and user-friendly software. I can apply similar error-handling techniques in my ticketing application to handle unexpected scenarios gracefully, even in a console-based environment.

Modularization: I've organized my code into functions (e.g., calculate, cm_to_in, in_to_cm) for improved readability and maintainability. Modularization is a best practice that I can apply to my ticketing project to keep my code organized and manageable as it grows, even in a console-based application.

Data Processing and Logic: My calculator project involves converting input values and performing mathematical calculations. These skills are beneficial for processing and managing data in my ticketing application, where I'll need to handle and manipulate ticket information and user input through the console.

User Experience (UX): By designing a text-based calculator interface, I've explored concepts related to creating a positive user experience even in a console-based environment. This UX-focused mindset can guide me in enhancing the usability and accessibility of my text-based ticketing application.

~ ~ ~   ~ ~ ~    ~ ~ ~    ~ ~ ~    ~ ~ ~

A little back story:

Calculator Project (Level-4):

In my Level 4 calculator project, I had the chance to dive into the world of GUI-based development. I was tasked with creating a GUI calculator using Python, which was both exciting and challenging.

Designing the GUI calculator exposed me to a whole new set of principles and processes, especially in terms of user interface (UI) design. I wanted to make sure the interface was user-friendly, but I must admit that I encountered my fair share of difficulties along the way. There were moments when I had to reconsider the layout, event handling, and how to prevent errors to make the calculator as intuitive as possible.

When it came to design principles, I tried to organize the code into functions to keep it clean and maintainable. However, this wasn't always straightforward, and I found myself going back and forth on certain design choices. My comments in the code reflected my thought process during these design dilemmas.

To integrate research into my practice, I did some reading on GUI design best practices and event-driven programming. This research certainly helped, but it was also a trial-and-error process. There were times when I had to experiment with different approaches and adjust the code based on what worked best in practice. It was a learning curve, but a valuable one.



Ticketing System (Level-5):

Now, shifting to the ticketing system project, it was a whole different ballgame as it was console-based. This meant that user interactions occurred through text commands in the command line.

In terms of design, I had to focus on principles related to console application development. This included figuring out how to handle user input, structure the code, and manage errors effectively. It was a different kind of challenge compared to GUI development.

I tried my best to structure the code into functions for readability and maintainability, but I'd be lying if I said it was a breeze. There were moments when I questioned whether I had organized the code optimally for user interactions and data processing. My comments revealed the back-and-forth nature of my decision-making.

To integrate research into practice, I researched techniques for user input validation and error handling in console-based applications. While this research was helpful, there were instances where my initial implementation didn't quite align with what I had learned. This required practical adjustments and some trial and error to get things right.

In sum, my learning journey involved navigating the challenges and uncertainties of both GUI and console-based development. It was marked by exploration, design dilemmas, and a lot of hands-on learning through experimentation and adjustments.

~ ~ ~   ~ ~ ~    ~ ~ ~    ~ ~ ~    ~ ~ ~
